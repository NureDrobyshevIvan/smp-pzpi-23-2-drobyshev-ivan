Харківський національний університет радіоелектроніки
Факультет комп’ютерних наук
Катедра програмної інженерії 
 
  

Звіт
з лабораторної роботи № 1
з дисципліни «Скриптові мови програмування»






Виконав:
ст. гр. ПЗПІ-23-2
Дробишев І. С. Перевірив
ст. викладач катедри ПІ
Сокорчук І. П.
 
Харків 2025
1 ІСТОРІЯ ЗМІН


№ 	Дата	       Версія звіту   	Опис змін та виправлень
1 	28.05.2025	 0.1	            Створено такі розділи: "Завдання", "Опис виконаної роботи", "Висновки". Були оформлені додатки


2 ЗАВДАННЯ

     – Ознайомитися з основними командами Bash для роботи з файлами та текстовими даними
     – Навчитися використовувати команди: `select`,`ls`,`awk`,`sort`,`uniq`,`tee`,`cat`,`sed`,`iconv` тощо
     – Розробити Bash-скрипт, який обробляє експортований із сайту https://cist.nure.ua/ розклад занять для всіх груп потоку в форматі CSV та перетворює його у формат CSV для завантаження в Google Календар
     – Обробка файла:
      1. Читати вхідний CSV файл та вибирати рядки, що відповідають вибраній академічній групі, 
      2. Визначити порядкий номер для кожного заняття (лекція, практичне заняття, лабораторна робота) із врахуванням того, що лабораторні роботи складаються із двох пар, а решта занять — із однієї пари,
      3. Створити поле «Subject» із поля «Тема» вхідного CSV файла, але БЕЗ назви академічної групи та дефіса на початку цього поля ("ПЗПІ-23-1 - ПрПА Пз DL ПЗПІ-23-1"),
      4. Додати порядковий номер наприкінці теми (Subject) кожного заняття після крапки з комою (опис заняття; №1),
      5. Переформатувати дату та час до формату «mm/dd/yyyy, HH:MM AM|PM,» Gogle Календаря 12-годинний формат часу. Наприклад: 02/30/2025, 11:15 AM,
      6. Заповнити поле «Description» текстом із поля «Опис (Описание)» вхідного CSV файла
      7. Відформатувати дані відповідно до вимог Google Календаря https://support.google.com/calendar/.
      8. Виводити створені для Google Календаря дані у стандартний потік виведення, якщо це не заблоковано ключем -q або --quiet
      9. Записати результат у новий файл із назвою: `Google_TimeTable_??_??_20??.csv`, де `??_??_20??` — дата, що відповідає вхідному файлу.


3 ОПИС ВИКОНАНОЇ РОБОТИ

     Для початку було створено новий файл за допомогою команди touch. Весь код було написано саме в цьому створеному файлі
     В рядках 1-37 відбувається обробка аргументів, переданих користувачем(див. додаток Б.1). Спочатку перевіряється, чи було введено спеціальні команди (--help або --version). При їх виявленні скрипт виводить відповідну інформацію та завершує роботу. Якщо ж ні, аргументи додаються в масив та далі йде вже обробка цих аргументів: якщо аргументів немає – не виконується жодних дій, при наявності одного аргумента він інтерпретується як шлях до вхідного файлу, якщо аргументів два – перший вважається назвою академічної групи, а другий шляхом до файлу
     
       39 if [[ -z "$input" ]]; then
       40     files=($(ls -1 TimeTable_??_??_20??.csv 2>/dev/null | sort));
       41     if [[ ${#files[@]} -eq 0 ]]; then
       42         echo "Error: No matching CSV files found!" >&2;
       43         exit 1;
       44     fi
       45     echo "Select a file:"
       46     select file in "${files[@]}"; do
       47         if [[ -n "$file" ]]; then
       48             input="$file";
       49             break;
       50         fi
       51         echo "Invalid selection."
       52     done
       53 fi
       54
       55 if [[ ! -f "$input" ]]; then
       56     echo "Error: file '$input' not found." >&2;
       57     exit 1;
       58 fi
       59
       60 if [[ ! -r "$input" ]]; then
       61     echo "Error: cannot read '$input'." >&2;
       62     exit 2;
       63 fi
      
     В рядках 39-63 відбувається перевірка та валідація вхідного файлу. Спочатку скрипт перевіряє, чи було вказано шлях до файлу. Якщо шлях не вказано, автоматично виконується пошук CSV файлів, що відповідають шаблону TimeTable_??_??_20??.csv. Далі користувачу пропонується обрати один із знайдених файлів через інтерактивне меню. Після того, як файл визначено, скрипт перевіряє фізичне існування файлу. Якщо файл не існує, виводиться відповідне повідомлення про помилку і скрипт завершується. Наостанок перевіряється можливість читання файлу. Якщо файл неможливо прочитати, виводиться повідомлення про це і скрипт завершується.
     В рядках 65-101(див. додаток Б.1) виконується обробка CSV файлу та вибір академічної групи. Спочатку вміст файлу зчитується з перетворенням із кодування Windows (CP1251) в UTF-8 та нормалізацією символів нового рядка. Далі за допомогою утиліти awk проводиться аналіз даних для виявлення наявних у файлі академічних груп. Скрипт знаходить рядки, де перше поле містить назву групи у форматі "група - предмет", виділяє лише назву групи, сортує результати та видаляє дублікати. Після цього перевіряється, чи була група вже вказана користувачем як аргумент. Якщо ні, то перевіряється кількість знайдених груп - якщо знайдено лише одну, вона вибирається автоматично, в іншому випадку користувачу пропонується вибрати потрібну групу через інтерактивне меню. Наприкінці скрипт перевіряє, чи існує вибрана група серед знайдених, і якщо ні, виводить попередження.
     
      103 output_file="Google_${input}.csv"
      104
      105 echo "$content" |
      106 awk -v group="$selected_group" '
      107 BEGIN {
      108   print "Subject,Start Date,Start Time,End Date,End Time,Description"
      109   FPAT = "([^,]*)|(\"[^\"]*\")"
      110 }
      111 function ft(t){
      112   gsub(/:|"/," ",t);
      113   return strftime("%I:%M %p", mktime(1970" 01 01 " t));
      114 }
      115 function fd(d){
      116   gsub(/"/, "", d);
      117   split(d, parts, ".")
      118   return strftime("%m/%d/%Y", mktime(parts[3] " " parts[2] " " parts[1] " 00 00 00"));
      119 }
      120 $0 ~ "\""group" - " {
      121   sub("^\""group" - ","",$1); gsub("\"$","",$1)
      122   sd=fd($2); st=ft($3); ed=fd($4); et=ft($5)
      123   lsnum = ++lesson_per_day[$2];
      124  
      125   printf("\"%s; №%d\",%s,%s,%s,%s,%s\n",
      126     $1, lsnum, sd, st, ed, et, $12)
      127 }' | tee "$output_file"
     
     В рядках 103-127 відбувається формування вихідного файлу в форматі, сумісному з Google Calendar. Спочатку створюється ім'я вихідного файлу додаванням префіксу "Google_" до імені вхідного файлу. Потім скрипт обробляє зміст вхідного файлу за допомогою утиліти awk. У секції BEGIN виводиться заголовок CSV файлу з назвами колонок для Google Calendar та встановлюється шаблон розбору полів. Далі визначаються дві допоміжні функції: ft() для перетворення формату часу (з 24-годинного у 12-годинний формат з AM/PM) та fd() для перетворення формату дати (з DD.MM.YYYY в MM/DD/YYYY). Основна логіка фільтрації знаходить рядки, що відповідають вибраній групі, і для кожного такого рядка виконується форматування даних: видаляється префікс із назви предмета, перетворюються дати й час, обчислюється порядковий номер заняття для кожного дня, і вся інформація виводиться у вихідний файл у форматі, готовому для імпорту в Google Calendar. Результат одночасно зберігається у файл та виводиться на екран за допомогою команди tee.

4 ВИСНОВКИ

     Під час виконання лабораторної роботи я ознайомився з основними командами Bash для роботи з файлами та текстовими даними, навчився використовувати команди `select` `ls` `awk` `sort` `uniq` `tee` `cat` `sed` `iconv` тощо, розробив Bash скрипт для перетворення CSV файла розкладу занять у придатний для імпорту в Google Календар CSV формат


ДОДАТОК А
Відеозапис

Відеозапис презентації результатів лабораторної роботи: https://youtu.be/KJ6FElnKbqQ

Хронологічний опис відеозапису:
00:00 - Вступ
00:05 - Обробка параметрів 
00:41 - Надання юзеру можливості обирати файл та групу
02:52 - Основна логіка формування вихідного файлу 
05:26 - Демонстрація роботи програми

ДОДАТОК Б
Програмний код
Б.1 Файл smp-pzpi-23-2-drobyshev-ivan-lab1-code.bash

GitHub репозиторій: https://github.com/NureDrobyshevIvan/smp-pzpi-23-2-drobyshev-ivan/blob/main/Lab1/smp-pzpi-23-2-drobyshev-ivan-lab1/smp-pzpi-23-2-drobyshev-ivan-lab1-code.bash

        1 #!/bin/bash
        2 VERSION="1.0.0"
        3
        4 declare -a args=()
        5
        6 while [[ $# -gt 0 ]]; do
        7     case "$1" in
        8         --help)
        9             echo "Usage: $(basename $0) [--help | --version] | [[-q|--quiet] [академ_група] файл_із_cist.csv]"
       10             exit 0
       11             ;;
       12         --version)
       13             echo "$(basename $0) version $VERSION"
       14             exit 0
       15             ;;
       16         *)
       17             args+=("$1")
       18             ;;
       19     esac
       20     shift
       21 done
       22
       23 case "${#args[@]}" in
       24     0)
       25         ;;
       26     1)
       27         input="${args[0]}"
       28         ;;
       29     2)
       30         selected_group="${args[0]}"
       31         input="${args[1]}"
       32         ;;
       33     *)
       34         echo "Error: Too many arguments" >&2
       35         exit 1
       36         ;;
       37 esac
       38
       39 if [[ -z "$input" ]]; then
       40     files=($(ls -1 TimeTable_??_??_20??.csv 2>/dev/null | sort));
       41     if [[ ${#files[@]} -eq 0 ]]; then
       42         echo "Error: No matching CSV files found!" >&2;
       43         exit 1;
       44     fi
       45     echo "Select a file:"
       46     select file in "${files[@]}"; do
       47         if [[ -n "$file" ]]; then
       48             input="$file";
       49             break;
       50         fi
       51         echo "Invalid selection."
       52     done
       53 fi
       54
       55 if [[ ! -f "$input" ]]; then
       56     echo "Error: file '$input' not found." >&2;
       57     exit 1;
       58 fi
       59
       60 if [[ ! -r "$input" ]]; then
       61     echo "Error: cannot read '$input'." >&2;
       62     exit 2;
       63 fi
       64
       65 content=$(sed 's/\r/\n/g' "$input" | iconv -f cp1251 -t utf-8)
       66
       67 found_groups=$(
       68   echo "$content" |
       69   awk -v FPAT='[^,]*|"[^"]*"' '
       70     NR>1 {
       71       gsub(/^"/,"",$1)
       72       if(match($1,/- /)){
       73         split($1,parts," - ")
       74         print parts[1]
       75       }
       76     }
       77   ' | sort -u
       78 )
       79
       80 group_count=$(echo "$found_groups" | wc -l)
       81 readarray -t groups_array <<<"$found_groups"
       82
       83 if [[ -z "$selected_group" ]]; then
       84   if (( group_count == 1 )); then
       85       selected_group="${groups_array[0]}"
       86   else
       87       echo "Select a group:"
       88       select group_choice in "${groups_array[@]}"; do
       89           if [[ -n "$group_choice" ]]; then
       90               selected_group="$group_choice"
       91               break
       92           else
       93               echo "Invalid selection."
       94           fi
       95       done
       96   fi
       97 fi
       98
       99 if ! grep "$selected_group" <<<"$found_groups"; then
      100     echo "Warning: Group $selected_group might not be in this file"
      101 fi
      102
      103 output_file="Google_${input}.csv"
      104
      105 echo "$content" |
      106 awk -v group="$selected_group" '
      107 BEGIN {
      108   print "Subject,Start Date,Start Time,End Date,End Time,Description"
      109   FPAT = "([^,]*)|(\"[^\"]*\")"
      110 }
      111 function ft(t){
      112   gsub(/:|"/," ",t);
      113   return strftime("%I:%M %p", mktime(1970" 01 01 " t));
      114 }
      115 function fd(d){
      116   gsub(/"/, "", d);
      117   split(d, parts, ".")
      118   return strftime("%m/%d/%Y", mktime(parts[3] " " parts[2] " " parts[1] " 00 00 00"));
      119 }
      120 $0 ~ "\""group" - " {
      121   sub("^\""group" - ","",$1); gsub("\"$","",$1)
      122   sd=fd($2); st=ft($3); ed=fd($4); et=ft($5)
      123   lsnum = ++lesson_per_day[$2];
      124
      125   printf("\"%s; №%d\",%s,%s,%s,%s,%s\n",
      126     $1, lsnum, sd, st, ed, et, $12)
      127 }' | tee "$output_file"


